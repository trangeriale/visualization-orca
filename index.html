<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <link rel="stylesheet" href="styles/index.css">
</head>

<body>
    <!--<svg style="width:500px;height:500px;border:1px lightgray solid;"></svg>-->
    <div id="cities"></div>
</body>
<script>
    /*
d3.select("body")
    .append("svg")
    .attr("width", 500)
    .attr("height", 500)

d3.select("svg").append("line")
    .attr("x1", 20)
    .attr("y1", 20)
    .attr("x2", 400)
    .attr("y2", 400)
    .style("stroke", "black")
    .style("stroke-width", "2px")

d3.select("svg")
    .append("circle")
    .attr("r", 30)
    .attr("cx", 40)
    .attr("cy", 40)
    .attr("fill", "blue")
    .transition().delay(1000).style("opacity", 0.75)


    d3.csv("cities.csv", (error, data) => {
        if (error) {
            console.error(error)
        }
        else {
            dataViz(data)
        }
    });

    function dataViz(incomingData) {
        d3.select("div.cities").selectAll("div.cities")
            .data(incomingData)
            .enter()
            .append("div")
            .attr("class", "cities")
            .html(d => d.label);
    }

    /*
    
        function dataViz(incomingData) {
            incomingData.forEach(d => {
                d.impact = d.favorites.length + d.retweets.length;
                d.tweetTime = new Date(d.timestamp);
            })
            var maxImpact = d3.max(incomingData, d => d.impact);
            var startEnd = d3.extent(incomingData, d => d.tweetTime);
            var timeRamp = d3.scaleTime().domain(startEnd).range([20, 480]);
            var yScale = d3.scaleLinear().domain([0, maxImpact]).range([0, 460]);
            var radiusScale = d3.scaleLinear()
                .domain([0, maxImpact]).range([1, 20]);
            var colorScale = d3.scaleLinear()
                .domain([0, maxImpact]).range(["white", "#75739F"]);
            d3.select("svg")
                .selectAll("circle")
                .data(incomingData)
                .enter()
                .append("circle")
                .attr("r", d => radiusScale(d.impact))
                .attr("cx", d => timeRamp(d.tweetTime))
                .attr("cy", d => 480 - yScale(d.impact))
                .style("fill", d => colorScale(d.impact))
                .style("stroke", "black")
                .style("stroke-width", "1px");
        };
    
        dataViz('tweets.json')
    */
    let rawData;

    d3.json("raw.json").then((data) => { rawData = data.obs; vizJSON(rawData) })

    //main function
    const vizJSON = function (data) {
        console.log("num obs", data.length)
        let totalConf = 0;
        let numConf = 0;
        let maxConf = 0;
        let minConf = 100;

        /*
        if he wants to highlight what time of day
        might be good to have a filter of time/season
        let's play with the scale first

        Explore confidence level data
        */

        for (let d in data) {
            //console.log("prediction", data[d].predictions)
            let pred = data[d].predictions
            for (let predId in pred) {
                if (pred[predId].confidence < minConf) {
                    minConf = pred[predId].confidence
                }
                //console.log(pred[predId].confidence)
                if (pred[predId].confidence > maxConf) {
                    maxConf = pred[predId].confidence
                }
                totalConf += pred[predId].confidence;

                numConf += 1;
            }
        }

        //console.log("average confidence rate", totalConf / numConf)
        //console.log("maximum", max)
        //console.log("min", min)

        //const latestDate = d3.max(data, d => d.timestamp)
        let timeRange = d3.extent(data, d => d.timestamp).map((date) => new Date(date))

        //timeRange = [new Date(timeRange[0]), new Date(timeRange[1])]

        const width = 9000
        const height = 1000, m = width > 599 ? 90 : 10;

        const timeScale = d3.scaleTime().domain(timeRange).range([m, width - m]).nice()
        //visualizeTicks(d3.scaleTime().domain([timeRange]).range([0, 5000]))
        console.log(timeRange)
        console.log('max', timeScale(timeRange[1]))
        console.log('sclae', timeScale(new Date("2021-09-17T15:03:34.014986Z")))
        //60 minute interval
        const intScale = d3.scaleLinear().domain([0, 60]).range([height - m, m])

        const durScale = d3.scaleLinear().domain([0, 60]).range([0, height - m])
        const colorScale = d3.scaleLinear().domain([minConf, maxConf]).range(["#D85656", "#009429"])

        let count = 0;
        //add axes with time and 60 second interval scale
        d3.select("body")
            .append("svg")
            .attr("class", "timeline")
            //.attr("viewBox", "0 0 30 5000")
            //.attr("xmlns", "http://www.w3.org/2000/svg")
            .attr("width", width)
            .attr("height", height)
            .append("g")
            .attr("class", "xaxis")
            .attr("transform", `translate(${0}, ${height - m})`)
            .call(d3.axisBottom(timeScale)
                .ticks(d3.timeMonth)
                .tickFormat(
                    d => d.toLocaleString('default', { month: 'long' }))
            )
            .append("g")
            .attr("transform", `translate(${m - 20},${-height + m})`)
            .call(d3.axisLeft(intScale)
                .ticks(5)
            )
        const chart = d3.select("svg.timeline")
        let lastObs = null
        for (let d in data) {
            count += 1
            lastObs = data[d]
            //have to index d from data because d is the key when we use for.. in for a dictionary
            let timePos = new Date(data[d].timestamp)
            let id = data[d].id
            let predData = data[d].predictions
            //console.log("loop #", d, predData)


            let dataPoints = chart.append("g")
                .selectAll("circle")
                .data(predData)
                .enter()
                .append("circle")
                .attr("cx", timeScale(timePos))
                .attr("r", d => durScale(d.duration) / 2)
                .attr("cy", d => intScale(d.startTime) - durScale(d.duration) / 2)
                //(height - m - intScale(d.duration)) / 2
                .attr("fill", d => colorScale(d.confidence))
                .attr("fill-opacity", "0.5")
                .on("click", (d) => console.log(d, d.duration, "at id", id))
        }

        console.log(count, "test count")
        console.log(lastObs)
        console.log(lastObs.predictions)
        //(d) => d.getFullYear() === 2020 ? "blue" : "red"))
        /*
        d3.select("body").selectAll("div.time")
            .data(data)
            .enter()
            .append("h1")
            .attr("class", "time")
            .html((data) => data.timestamp)*/
    }

    /*
    function dataViz(incomingData) {
        incomingData.forEach(d => {
            d.impact = d.favorites.length + d.retweets.length;
            d.tweetTime = new Date(d.timestamp);
        })
        var maxImpact = d3.max(incomingData, d => d.impact);
        var startEnd = d3.extent(incomingData, d => d.tweetTime);
        var timeRamp = d3.scaleTime().domain(startEnd).range([20, 480]);
        var yScale = d3.scaleLinear().domain([0, maxImpact]).range([0, 460]);
        var radiusScale = d3.scaleLinear()
            .domain([0, maxImpact]).range([1, 20]);
        var colorScale = d3.scaleLinear()
            .domain([0, maxImpact]).range(["white", "#75739F"]);
        d3.select("svg")
            .selectAll("circle")
            .data(incomingData)
            .enter()
            .append("circle")
            .attr("r", d => radiusScale(d.impact))
            .attr("cx", d => timeRamp(d.tweetTime))
            .attr("cy", d => 480 - yScale(d.impact))
            .style("fill", d => colorScale(d.impact))
            .style("stroke", "black")
            .style("stroke-width", "1px");
    };*/


</script>

</html>